{"version":3,"sources":["src/dispatcher.js"],"names":[],"mappings":"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","file":"src/dispatcher.js","sourcesContent":["var _current;\nvar _tokenCounter = 1;\nvar _idCounter = 1;\n\nexport class Dispatcher {\n    static get current() {\n        if (!_current) {\n            _current = new Dispatcher();\n        }\n        return _current;\n    }\n\n    static set current(current) {\n        this._current = current;\n    }\n\n    constructor(id) {\n        this.id = id || `dispatcher-${_idCounter++}`;\n\n        this._callbacks = new Map();\n        this._dispatchQueue = [];\n\n        this._currentDispatch = false;\n        this._currentDispatchPromises = new Map();\n    }\n\n    /**\n     * Register a callback that will be called when an action is dispatched.\n     *\n     * @param  {Function} callback The callback to be called when an action is dispatched\n     * @return {String} The callback token that can be used to unregister this callback\n     */\n    register(token, callback) {\n        if (token instanceof Function) {\n            callback = token;\n            token = `luxyflux-callback-token-${_tokenCounter++}`;\n        }\n\n        this._callbacks.set(token, callback);\n\n        return token;\n    }\n\n    /**\n     * Unregister a callback from this dispatcher\n     *\n     * @param  {String} token The callback token to be unregistered from this dispatcher\n     */\n    unregister(token) {\n        return this._callbacks.delete(token);\n    }\n\n    /**\n     * Creates a promise and waits for the callbacks specified to complete before resolve it.\n     *\n     * @param  {String<Array>|String} tokens The callback tokens to wait for.\n     * @return {Promise} A promise to be resolved when the specified callbacks are completed.\n     */\n    waitFor(tokens) {\n        if (!Array.isArray(tokens)) {\n            tokens = [tokens];\n        }\n\n        var waitForPromises = [];\n\n        for (var token of tokens) {\n            if (this._currentDispatchPromises.has(token)) {\n                waitForPromises.push(this._currentDispatchPromises.get(token));\n            }\n        }\n\n        if (!waitForPromises.length) {\n            return Promise.resolve();\n        }\n\n        return Promise.all(waitForPromises);\n    }\n\n    /**\n     * Dispatches an action to all the registered callbacks/stores.\n     *\n     * If a second action is dispatched while there is a dispatch on, it will be\n     * enqueued an dispatched after the current one.\n     *\n     * @return { Promise } A promise to be resolved when all the callbacks have finised.\n     */\n    dispatch() {\n        var dispatchArguments = Array.from(arguments);\n        var promise;\n\n        // If we are in the middle of a dispatch, enqueue the dispatch\n        if (this._currentDispatch) {\n            // Dispatch after the current one\n            promise = this._currentDispatch.then(() => {\n                return this._dispatch.call(this, dispatchArguments);\n            });\n\n            // Enqueue, set the chain as the current promise and return\n            this._dispatchQueue.push(promise);\n        }\n        else {\n            promise = this._dispatch(dispatchArguments);\n        }\n\n        this._currentDispatch = promise;\n\n        return promise;\n    }\n\n    _dispatch(dispatchArguments) {\n        this._currentDispatchPromises.clear();\n\n        for (let [token, callback] of this._callbacks) {\n            // A closure is needed for the callback and token variables\n            ((token, callback) => {\n                // All the promises must be set in this._currentDispatchPromises\n                // before trying to resolved in order to make waitFor work\n                var promise = Promise.resolve()\n                    .then(() => {\n                        return this._executeCallback(callback, dispatchArguments);\n                    })\n                    .catch((e) => {\n                        throw new Error(e.stack || e);\n                    });\n\n                this._currentDispatchPromises.set(token, promise);\n            })(token, callback);\n        }\n\n        var dequeue = () => {\n            this._dispatchQueue.shift();\n            if (!this._dispatchQueue.length) {\n                this._currentDispatch = false;\n            }\n        };\n        var dispatchPromises = Array.from(this._currentDispatchPromises.values());\n        return Promise.all(dispatchPromises).then(dequeue, dequeue);\n    }\n\n    _executeCallback(callback, dispatchArguments) {\n        return callback.apply(this, dispatchArguments);\n    }\n\n    /**\n     * Is this dispatcher currently dispatching.\n     *\n     * @return {Boolean}\n     */\n    isDispatching() {\n        return !!this._dispatchQueue.length;\n    }\n}\n\nexport default Dispatcher;\n"]}