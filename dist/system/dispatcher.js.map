{"version":3,"sources":["../../src/dispatcher.js"],"names":[],"mappings":"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","file":"dispatcher.js","sourcesContent":["var _current;\nvar _tokenCounter = 1;\nvar _idCounter = 1;\n\nexport class Dispatcher {\n    static get current() {\n        if (!_current) {\n            _current = new Dispatcher();\n        }\n        return _current;\n    }\n\n    static set current(current) {\n        this._current = current;\n    }\n\n    constructor(id) {\n        this.id = id || `dispatcher-${_idCounter++}`;\n\n        this._callbacks = new Map();\n        this._dispatchQueue = [];\n\n        this._currentDispatch = false;\n        this._currentDispatchPromises = new Map();\n    }\n\n    /**\n     * Register a callback that will be called when an action is dispatched.\n     *\n     * @param  {Function} callback The callback to be called when an action is dispatched\n     * @return {String} The callback token that can be used to unregister this callback\n     */\n    register(token, callback) {\n        if (token instanceof Function) {\n            callback = token;\n            token = `luxyflux-callback-token-${_tokenCounter++}`;\n        }\n\n        this._callbacks.set(token, callback);\n\n        return token;\n    }\n\n    /**\n     * Unregister a callback from this dispatcher\n     *\n     * @param  {String} token The callback token to be unregistered from this dispatcher\n     */\n    unregister(token) {\n        return this._callbacks.delete(token);\n    }\n\n    /**\n     * Creates a promise and waits for the callbacks specified to complete before resolve it.\n     *\n     * @param  {String<Array>|String} tokens The callback tokens to wait for.\n     * @return {Promise} A promise to be resolved when the specified callbacks are completed.\n     */\n    waitFor(tokens) {\n        if (!Array.isArray(tokens)) {\n            tokens = [tokens];\n        }\n\n        var waitForPromises = [];\n\n        for (var token of tokens) {\n            if (this._currentDispatchPromises.has(token)) {\n                waitForPromises.push(this._currentDispatchPromises.get(token));\n            }\n        }\n\n        if (!waitForPromises.length) {\n            return Promise.resolve();\n        }\n\n        return Promise.all(waitForPromises);\n    }\n\n    /**\n     * Dispatches an action to all the registered callbacks/stores.\n     *\n     * If a second action is dispatched while there is a dispatch on, it will be\n     * enqueued an dispatched after the current one.\n     *\n     * @return { Promise } A promise to be resolved when all the callbacks have finised.\n     */\n    dispatch() {\n        var dispatchArguments = Array.from(arguments);\n        var promise;\n\n        // If we are in the middle of a dispatch, enqueue the dispatch\n        if (this._currentDispatch) {\n            // Dispatch after the current one\n            promise = this._currentDispatch.then(() => {\n                return this._dispatch.call(this, dispatchArguments);\n            });\n\n            // Enqueue, set the chain as the current promise and return\n            this._dispatchQueue.push(promise);\n        }\n        else {\n            promise = this._dispatch(dispatchArguments);\n        }\n\n        this._currentDispatch = promise;\n\n        return promise;\n    }\n\n    _dispatch(dispatchArguments) {\n        this._currentDispatchPromises.clear();\n\n        for (let [token, callback] of this._callbacks) {\n            // A closure is needed for the callback and token variables\n            ((token, callback) => {\n                // All the promises must be set in this._currentDispatchPromises\n                // before trying to resolved in order to make waitFor work\n                var promise = Promise.resolve()\n                    .then(() => {\n                        return this._executeCallback(callback, dispatchArguments);\n                    })\n                    .catch((e) => {\n                        throw new Error(e.stack || e);\n                    });\n\n                this._currentDispatchPromises.set(token, promise);\n            })(token, callback);\n        }\n\n        var dequeue = () => {\n            this._dispatchQueue.shift();\n            if (!this._dispatchQueue.length) {\n                this._currentDispatch = false;\n            }\n        };\n        var dispatchPromises = Array.from(this._currentDispatchPromises.values());\n        return Promise.all(dispatchPromises).then(dequeue, dequeue);\n    }\n\n    _executeCallback(callback, dispatchArguments) {\n        return callback.apply(this, dispatchArguments);\n    }\n\n    /**\n     * Is this dispatcher currently dispatching.\n     *\n     * @return {Boolean}\n     */\n    isDispatching() {\n        return !!this._dispatchQueue.length;\n    }\n}\n\nexport default Dispatcher;\n"]}