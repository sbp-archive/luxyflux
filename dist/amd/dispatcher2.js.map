{"version":3,"sources":["src/dispatcher2.js"],"names":[],"mappings":"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","file":"src/dispatcher2.js","sourcesContent":["var _current;\nvar _tokenCounter = 1;\nvar _idCounter = 1;\n\nexport class Dispatcher {\n    static get current() {\n        if (!_current) {\n            _current = new Dispatcher();\n        }\n        return _current;\n    }\n\n    static set current(current) {\n        this._current = current;\n    }\n\n    constructor(id) {\n        this.id = id || `dispatcher-${_idCounter++}`;\n\n        this._callbacks = new Map();\n        this._dispatchQueue = [];\n\n        this._currentDispatch = false;\n        this._currentDispatchPromises = new Map();\n    }\n\n    /**\n     * Register a callback that will be called when an action is dispatched.\n     *\n     * @param  {Function} callback The callback to be called when an action is dispatched\n     * @return {String} The callback token that can be used to unregister this callback\n     */\n    register(token, callback) {\n        if (token instanceof Function) {\n            callback = token;\n            token = `luxyflux-callback-token-${_tokenCounter++}`;\n        }\n\n        this._callbacks.set(token, callback);\n\n        return token;\n    }\n\n    /**\n     * Unregister a callback from this dispatcher\n     *\n     * @param  {String} token The callback token to be unregistered from this dispatcher\n     */\n    unregister(token) {\n        return this._callbacks.delete(token);\n    }\n\n    /**\n     * Creates a promise and waits for the callbacks specified to complete before resolve it.\n     *\n     * @param  {String<Array>|String} tokens The callback tokens to wait for.\n     * @return {Promise} A promise to be resolved when the specified callbacks are completed.\n     */\n    waitFor(tokens) {\n        if (!Array.isArray(tokens)) {\n            tokens = [tokens];\n        }\n\n        var waitForPromises = [];\n\n        for (var token of tokens) {\n            if (this._currentDispatchPromises.has(token)) {\n                waitForPromises.push(this._currentDispatchPromises.get(token));\n            }\n        }\n\n        if (!waitForPromises.length) {\n            return Promise.resolve();\n        }\n\n        return Promise.all(waitForPromises);\n    }\n\n    /**\n     * Dispatches an action to all the registered callbacks/stores.\n     *\n     * If a second action is dispatched while there is a dispatch on, it will be\n     * enqueued an dispatched after the current one.\n     *\n     * @return { Promise } A promise to be resolved when all the callbacks have finised.\n     */\n    dispatch() {\n        var dispatchArguments = Array.from(arguments);\n        var promise;\n\n        // If we are in the middle of a dispatch, enqueue the dispatch\n        if (this._currentDispatch) {\n            // Dispatch after the current one\n            promise = this._currentDispatch.then(() => {\n                return this._dispatch.call(this, dispatchArguments);\n            });\n\n            // Enqueue, set the chain as the current promise and return\n            this._dispatchQueue.push(promise);\n        }\n        else {\n            promise = this._dispatch(dispatchArguments);\n        }\n\n        this._currentDispatch = promise;\n\n        return promise;\n    }\n\n    _dispatch(dispatchArguments) {\n        this._currentDispatchPromises.clear();\n\n        for (let [token, callback] of this._callbacks) {\n            // A closure is needed for the callback and token variables\n            ((token, callback) => {\n                // All the promises must be set in this._currentDispatchPromises\n                // before trying to resolved in order to make waitFor work\n                var promise = Promise.resolve()\n                    .then(() => {\n                        return this._executeCallback(callback, dispatchArguments);\n                    })\n                    .catch((e) => {\n                        throw new Error(e.stack || e);\n                    });\n\n                this._currentDispatchPromises.set(token, promise);\n            })(token, callback);\n        }\n\n        var dequeue = () => {\n            this._dispatchQueue.shift();\n            if (!this._dispatchQueue.length) {\n                this._currentDispatch = false;\n            }\n        };\n        var dispatchPromises = Array.from(this._currentDispatchPromises.values());\n        return Promise.all(dispatchPromises).then(dequeue, dequeue);\n    }\n\n    _executeCallback(callback, dispatchArguments) {\n        return callback.apply(this, dispatchArguments);\n    }\n\n    /**\n     * Is this dispatcher currently dispatching.\n     *\n     * @return {Boolean}\n     */\n    isDispatching() {\n        return !!this._dispatchQueue.length;\n    }\n}\n\nexport default Dispatcher;\n"]}