{"version":3,"sources":["../../src/dispatcher.js"],"names":[],"mappings":"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","file":"dispatcher.js","sourcesContent":["var _current;\nvar _tokenCounter = 1;\nvar _idCounter = 1;\n\nexport class Dispatcher {\n    static get current() {\n        if (!_current) {\n            _current = new Dispatcher();\n        }\n        return _current;\n    }\n\n    static set current(current) {\n        this._current = current;\n    }\n\n    constructor(id) {\n        this.id = id || `dispatcher-${_idCounter++}`;\n\n        this._callbacks = new Map();\n        this._dispatchQueue = [];\n\n        this._currentDispatch = false;\n        this._currentDispatchPromises = new Map();\n    }\n\n    /**\n     * Register a callback that will be called when an action is dispatched.\n     *\n     * @param  {Function} callback The callback to be called when an action is dispatched\n     * @return {String} The callback token that can be used to unregister this callback\n     */\n    register(token, callback) {\n        if (token instanceof Function) {\n            callback = token;\n            token = `luxyflux-callback-token-${_tokenCounter++}`;\n        }\n\n        this._callbacks.set(token, callback);\n\n        return token;\n    }\n\n    /**\n     * Unregister a callback from this dispatcher\n     *\n     * @param  {String} token The callback token to be unregistered from this dispatcher\n     */\n    unregister(token) {\n        return this._callbacks.delete(token);\n    }\n\n    /**\n     * Creates a promise and waits for the callbacks specified to complete before resolve it.\n     *\n     * @param  {String<Array>|String} tokens The callback tokens to wait for.\n     * @return {Promise} A promise to be resolved when the specified callbacks are completed.\n     */\n    waitFor(tokens) {\n        if (!Array.isArray(tokens)) {\n            tokens = [tokens];\n        }\n\n        var waitForPromises = [];\n\n        for (var token of tokens) {\n            if (this._currentDispatchPromises.has(token)) {\n                waitForPromises.push(this._currentDispatchPromises.get(token));\n            }\n        }\n\n        if (!waitForPromises.length) {\n            return Promise.resolve();\n        }\n\n        return Promise.all(waitForPromises);\n    }\n\n    /**\n     * Dispatches an action to all the registered callbacks/stores.\n     *\n     * If a second action is dispatched while there is a dispatch on, it will be\n     * enqueued an dispatched after the current one.\n     *\n     * @return { Promise } A promise to be resolved when all the callbacks have finised.\n     */\n    dispatch() {\n        var dispatchArguments = Array.from(arguments);\n        var promise;\n\n        // If we are in the middle of a dispatch, enqueue the dispatch\n        if (this._currentDispatch) {\n            // Dispatch after the current one\n            promise = this._currentDispatch.then(() => {\n                return this._dispatch.call(this, dispatchArguments);\n            });\n\n            // Enqueue, set the chain as the current promise and return\n            this._dispatchQueue.push(promise);\n        }\n        else {\n            promise = this._dispatch(dispatchArguments);\n        }\n\n        this._currentDispatch = promise;\n\n        return promise;\n    }\n\n    _dispatch(dispatchArguments) {\n        this._currentDispatchPromises.clear();\n\n        for (let [token, callback] of this._callbacks) {\n            // A closure is needed for the callback and token variables\n            ((token, callback) => {\n                // All the promises must be set in this._currentDispatchPromises\n                // before trying to resolved in order to make waitFor work\n                var promise = Promise.resolve()\n                    .then(() => {\n                        return this._executeCallback(callback, dispatchArguments);\n                    })\n                    .catch((e) => {\n                        throw new Error(e.stack || e);\n                    });\n\n                this._currentDispatchPromises.set(token, promise);\n            })(token, callback);\n        }\n\n        var dequeue = () => {\n            this._dispatchQueue.shift();\n            if (!this._dispatchQueue.length) {\n                this._currentDispatch = false;\n            }\n        };\n        var dispatchPromises = Array.from(this._currentDispatchPromises.values());\n        return Promise.all(dispatchPromises).then(dequeue, dequeue);\n    }\n\n    _executeCallback(callback, dispatchArguments) {\n        return callback.apply(this, dispatchArguments);\n    }\n\n    /**\n     * Is this dispatcher currently dispatching.\n     *\n     * @return {Boolean}\n     */\n    isDispatching() {\n        return !!this._dispatchQueue.length;\n    }\n}\n\nexport default Dispatcher;\n"]}